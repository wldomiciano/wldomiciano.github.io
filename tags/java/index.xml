<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Wellington Domiciano</title><link>https://wldomiciano.com/tags/java/</link><description>Recent content in Java on Wellington Domiciano</description><generator>Hugo</generator><language>pt-br</language><lastBuildDate>Thu, 12 Oct 2023 12:00:00 -0300</lastBuildDate><atom:link href="https://wldomiciano.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Métodos obsoletos da HttpSecurity no Spring Security 6.1</title><link>https://wldomiciano.com/metodos-obsoletos-da-httpsecurity-spring-security-6-1/</link><pubDate>Sat, 29 Jul 2023 00:00:00 +0000</pubDate><guid>https://wldomiciano.com/metodos-obsoletos-da-httpsecurity-spring-security-6-1/</guid><description>No Spring Security 6.1 vários métodos da classe HttpSecurity tornaram-se obsoletos e isto afeta projetos criados com Spring Boot a partir da versão 3.1.
Métodos como cors(), csrf(), authorizeHttpRequests(), etc&amp;hellip; não devem mais ser usados, pois a expectativa é de que sejam removidos no Spring Security 7.
O que devemos usar atualmente é a versão destes métodos que aceita um Customizer como argumento, o que a documentação chama de Lambda DSL.</description></item><item><title>O método toString do Java</title><link>https://wldomiciano.com/o-metodo-to-string-do-java/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://wldomiciano.com/o-metodo-to-string-do-java/</guid><description>Criou uma classe maneira e na hora de mostrar o resultado com print() viu uns números estranhos?
class User { private String name; private int age; User(String name, int age) { this.name = name; this.age = age; } } public class Main { public static void main(String... args) { User user = new User(&amp;#34;João&amp;#34;, 29); System.out.println(user); // Apenas um ex.: User@1a2b3c } } Não se preocupe, a sua classe está apenas usando o método toString() implementado na classe Object.</description></item><item><title>Como agrupar asserts no JUnit</title><link>https://wldomiciano.com/como-agrupar-asserts-no-junit/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://wldomiciano.com/como-agrupar-asserts-no-junit/</guid><description>Pode haver momentos em que precisamos usar múltiplos asserts em um mesmo teste. Independente se você considera certo ou errado, afinal não estamos aqui para julgar, eu gostaria de apresentar uma forma de lidar melhor com estes asserts agrupando-os através do método assertAll().
No código abaixo eu tenho 2 testes, cada um com 2 asserts que falham. No primeiro eu usei asserts individuais enquanto no segundo eu os agrupei.
import static org.</description></item><item><title>A classe Boolean do Java</title><link>https://wldomiciano.com/a-classe-boolean-do-java/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://wldomiciano.com/a-classe-boolean-do-java/</guid><description>A partir do Java 9 os construtores da classe Boolean tornaram-se obsoletos e quando queremos usar instâncias de Boolean usamos as constantes Boolean.TRUE ou Boolean.FALSE.
Podemos obter uma destas constantes a partir de um primitivo usando o método Boolean.valueOf().
System.out.println(Boolean.valueOf(true) == Boolean.TRUE); // true System.out.println(Boolean.valueOf(false) == Boolean.FALSE); // true Este método também aceita uma String que, se for igual a palavra true ignorando se as letras são maiúsculas ou minúsculas, o resultado será igual a Boolean.</description></item><item><title>Como ler e escrever arquivos de texto com Java</title><link>https://wldomiciano.com/como-ler-e-escrever-arquivos-de-texto-em-java/</link><pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate><guid>https://wldomiciano.com/como-ler-e-escrever-arquivos-de-texto-em-java/</guid><description>Neste artigo eu apresento alguns casos de usos simples de leitura e escrita de arquivos de texto com Java.
Leitura O código abaixo mostra como retornar todo o conteúdo de um arquivo de texto como uma String.
import static java.nio.charset.StandardCharsets.UTF_16; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; public class ReadingAllContent { public static void main(String... args) { try { Path path = Paths.get(&amp;#34;text.txt&amp;#34;); byte[] bytes = Files.readAllBytes(path); String content = new String(bytes, UTF_16); System.</description></item></channel></rss>